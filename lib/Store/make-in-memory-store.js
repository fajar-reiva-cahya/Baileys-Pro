var __importDefault=this&&this.__importDefault||function(f){return f&&f.__esModule?f:{"default":f}};Object.defineProperty(exports,"__esModule",{value:!0});exports.waLabelAssociationKey=exports.waMessageID=exports.waChatKey=void 0;
const WAProto_1=require("../../WAProto"),Defaults_1=require("../Defaults"),LabelAssociation_1=require("../Types/LabelAssociation"),Utils_1=require("../Utils"),WABinary_1=require("../WABinary"),make_ordered_dictionary_1=__importDefault(require("./make-ordered-dictionary")),object_repository_1=require("./object-repository"),waChatKey=f=>({key:g=>(f?g.pinned?"1":"0":"")+(g.archived?"0":"1")+(g.conversationTimestamp?g.conversationTimestamp.toString(16).padStart(8,"0"):"")+g.id,compare:(g,w)=>w.localeCompare(g)});
exports.waChatKey=waChatKey;const waMessageID=f=>f.key.id||"";exports.waMessageID=waMessageID;exports.waLabelAssociationKey={key:f=>f.type===LabelAssociation_1.LabelAssociationType.Chat?f.chatId+f.labelId:f.chatId+f.messageId+f.labelId,compare:(f,g)=>g.localeCompare(f)};const makeMessagesDictionary=()=>(0,make_ordered_dictionary_1.default)(exports.waMessageID);
exports.default=f=>{const g=f.socket,w=f.chatKey||(0,exports.waChatKey)(!0),y=f.labelAssociationKey||exports.waLabelAssociationKey,l=f.logger||Defaults_1.DEFAULT_CONNECTION_CONFIG.logger.child({stream:"in-mem-store"});f=require("@adiwajshing/keyed-db").default;const m=new f(w,b=>b.id),h={},k={},p={},v={},z={connection:"close"},q=new object_repository_1.ObjectRepository,r=new f(y,y.key),u=b=>{h[b]||(h[b]=makeMessagesDictionary());return h[b]},x=b=>{const a=new Set(Object.keys(k));for(const c of b)a.delete(c.id),
k[c.id]=Object.assign(k[c.id]||{},c);return a},A=()=>({chats:m,contacts:k,messages:h,labels:q,labelAssociations:r}),B=b=>{m.upsert(...b.chats);r.upsert(...(b.labelAssociations||[]));x(Object.values(b.contacts));var a=Object.values(b.labels||{});for(const c of a)q.upsertById(c.id,c);for(const c in b.messages){a=u(c);for(const d of b.messages[c])a.upsert(WAProto_1.proto.WebMessageInfo.fromObject(d),"append")}};return{chats:m,contacts:k,messages:h,groupMetadata:p,state:z,presences:v,labels:q,labelAssociations:r,
bind:b=>{b.on("connection.update",a=>{Object.assign(z,a)});b.on("messaging-history.set",({chats:a,contacts:c,messages:d,isLatest:e,syncType:n})=>{if(n!==WAProto_1.proto.HistorySync.HistorySyncType.ON_DEMAND){if(e){m.clear();for(const t in h)delete h[t]}a=m.insertIfAbsent(...a).length;l.debug({chatsAdded:a},"synced chats");a=x(c);if(e)for(const t of a)delete k[t];l.debug({deletedContacts:e?a.size:0,newContacts:c},"synced contacts");for(const t of d)u(t.key.remoteJid).upsert(t,"prepend");l.debug({messages:d.length},
"synced messages")}});b.on("contacts.upsert",a=>{x(a)});b.on("contacts.update",async a=>{var c;for(const d of a){k[d.id]?a=k[d.id]:(a=await Promise.all(Object.keys(k).map(async e=>{const {user:n}=(0,WABinary_1.jidDecode)(e);return[e,(await (0,Utils_1.md5)(Buffer.from(n+"WA_ADD_NOTIF","utf8"))).toString("base64").slice(0,3)]})),a=k[(null===(c=a.find(([,e])=>e===d.id))||void 0===c?void 0:c[0])||""]);if(a)"changed"===d.imgUrl?a.imgUrl=g?await (null===g||void 0===g?void 0:g.profilePictureUrl(a.id)):void 0:
"removed"===d.imgUrl&&delete a.imgUrl;else return l.debug({update:d},"got update for non-existant contact");Object.assign(k[a.id],a)}});b.on("chats.upsert",a=>{m.upsert(...a)});b.on("chats.update",a=>{for(let c of a)m.update(c.id,d=>{0<c.unreadCount&&(c={...c},c.unreadCount=(d.unreadCount||0)+c.unreadCount);Object.assign(d,c)})||l.debug({update:c},"got update for non-existant chat")});b.on("labels.edit",a=>{if(a.deleted)return q.deleteById(a.id);if(20>q.count())return q.upsertById(a.id,a);l.error("Labels count exceed")});
b.on("labels.association",({type:a,association:c})=>{switch(a){case "add":r.upsert(c);break;case "remove":r.delete(c);break;default:console.error(`unknown operation type [${a}]`)}});b.on("presence.update",({id:a,presences:c})=>{v[a]=v[a]||{};Object.assign(v[a],c)});b.on("chats.delete",a=>{for(const c of a)m.get(c)&&m.deleteById(c)});b.on("messages.upsert",({messages:a,type:c})=>{switch(c){case "append":case "notify":for(const d of a)a=(0,WABinary_1.jidNormalizedUser)(d.key.remoteJid),u(a).upsert(d,
"append"),"notify"!==c||m.get(a)||b.emit("chats.upsert",[{id:a,conversationTimestamp:(0,Utils_1.toNumber)(d.messageTimestamp),unreadCount:1}])}});b.on("messages.update",a=>{var c;for(const {update:d,key:e}of a){a=u((0,WABinary_1.jidNormalizedUser)(e.remoteJid));if(null===d||void 0===d?0:d.status){const n=null===(c=a.get(e.id))||void 0===c?void 0:c.status;n&&(null===d||void 0===d?void 0:d.status)<=n&&(l.debug({update:d,storedStatus:n},"status stored newer then update"),delete d.status,l.debug({update:d},
"new update object"))}a.updateAssign(e.id,d)||l.debug({update:d},"got update for non-existent message")}});b.on("messages.delete",a=>{if("all"in a)a=h[a.jid],null===a||void 0===a||a.clear();else{const c=h[a.keys[0].remoteJid];if(c){const d=new Set(a.keys.map(e=>e.id));c.filter(e=>!d.has(e.key.id))}}});b.on("groups.update",a=>{for(const c of a)a=c.id,p[a]?Object.assign(p[a],c):l.debug({update:c},"got update for non-existant group metadata")});b.on("group-participants.update",({id:a,participants:c,
action:d})=>{if(a=p[a])switch(d){case "add":a.participants.push(...c.map(e=>({id:e,isAdmin:!1,isSuperAdmin:!1})));break;case "demote":case "promote":for(const e of a.participants)c.includes(e.id)&&(e.isAdmin="promote"===d);break;case "remove":a.participants=a.participants.filter(e=>!c.includes(e.id))}});b.on("message-receipt.update",a=>{for(const {key:c,receipt:d}of a)a=h[c.remoteJid],(a=null===a||void 0===a?void 0:a.get(c.id))&&(0,Utils_1.updateMessageWithReceipt)(a,d)});b.on("messages.reaction",
a=>{for(const {key:c,reaction:d}of a)a=h[c.remoteJid],(a=null===a||void 0===a?void 0:a.get(c.id))&&(0,Utils_1.updateMessageWithReaction)(a,d)})},loadMessages:async(b,a,c)=>{b=u(b);const d=!c||"before"in c?"before":"after",e=c?"before"in c?c.before:c.after:void 0;c=e?b.get(e.id):void 0;!b||"before"!==d||e&&!c?b=[]:(c?(c=b.array.findIndex(n=>n.key.id===(null===e||void 0===e?void 0:e.id)),b=b.array.slice(0,c)):b=b.array,0>a-b.length&&(b=b.slice(-a)));return b},getLabels:()=>q,getChatLabels:b=>r.filter(a=>
a.chatId===b).all(),getMessageLabels:b=>r.filter(a=>a.messageId===b).all().map(({labelId:a})=>a),loadMessage:async(b,a)=>{var c;return null===(c=h[b])||void 0===c?void 0:c.get(a)},mostRecentMessage:async b=>{var a;return null===(a=h[b])||void 0===a?void 0:a.array.slice(-1)[0]},fetchImageUrl:async(b,a)=>{const c=k[b];if(!c)return null===a||void 0===a?void 0:a.profilePictureUrl(b);"undefined"===typeof c.imgUrl&&(c.imgUrl=await (null===a||void 0===a?void 0:a.profilePictureUrl(b)));return c.imgUrl},fetchGroupMetadata:async(b,
a)=>{p[b]||(a=await (null===a||void 0===a?void 0:a.groupMetadata(b)))&&(p[b]=a);return p[b]},fetchMessageReceipts:async({remoteJid:b,id:a})=>{b=h[b];a=null===b||void 0===b?void 0:b.get(a);return null===a||void 0===a?void 0:a.userReceipt},toJSON:A,fromJSON:B,writeToFile:b=>{const {writeFileSync:a}=require("fs");a(b,JSON.stringify(A()))},readFromFile:b=>{const {readFileSync:a,existsSync:c}=require("fs");c(b)&&(l.debug({path:b},"reading from file"),b=a(b,{encoding:"utf-8"}),b=JSON.parse(b),B(b))}}};
